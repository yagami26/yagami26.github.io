<!DOCTYPE html>
<html lang="en">
<head>
          <title>Khirod Blog - InOrder Successor of a node in a BST [LeetCode Medium]</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="writing about tech and randomness in universe" />
        <link href="https://yagami26.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Khirod Blog Full Atom Feed" />
        <link href="https://yagami26.github.io/feeds/algorithms.atom.xml" type="application/atom+xml" rel="alternate" title="Khirod Blog Categories Atom Feed" />




    <meta name="tags" content="leetcode" />
    <meta name="tags" content="binary-search-tree" />

</head>

<body>
        <header>
              <hgroup><h1><a href="https://yagami26.github.io/">Khirod Blog</a></h1><p>writing about tech and randomness in universe</p></hgroup>
        <nav><ul>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="https://yagami26.github.io/pages/about.html" >About</a></li>
            <li><a href="https://yagami26.github.io/pages/chess.html" >Chess</a></li>
            <li><a href="https://yagami26.github.io/category/algorithms.html"  aria-current="page" >Algorithms</a></li>
            <li><a href="https://yagami26.github.io/category/technology.html" >Technology</a></li>
        </ul></nav>
        </header>
        <main>
<article>
  <header>
    <h2>
      <a href="https://yagami26.github.io/post-10.html" rel="bookmark"
         title="Permalink to InOrder Successor of a node in a BST [LeetCode Medium]">InOrder Successor of a node in a BST [LeetCode Medium]</a></h2>
 
  </header>
  <p>The problem - <a href="https://leetcode.com/problems/inorder-successor-in-bst/description">Inorder successor of node in a bst</a>  </p>
<p>I had attempted the problem before but I was too focussed on not using any global variables when implementing the solution. I guess being a senior developer we just try to avoid using global variables. To be honest, I did end up using the global variables at the end (<em>I sucked up my pride!</em>). I implemented two approaches here</p>
<h3>Approach 1 (Naive Traversal)</h3>
<p>The naive approach where you inorder traverse a BST and keep a track whether the target node has been found or not in a global variable and then find the next node which is greater than target node. You don't recurse the tree further if the in order successor is found. This solution beat ~53% of solutions at runtime. At worse case it will still be O(N) because it will traverse the entire tree at worst case.   </p>
<div class="highlight"><pre><span></span><code><span class="k">var</span><span class="w"> </span><span class="n">foundTarget</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">false</span>
<span class="k">var</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span>

<span class="k">func</span><span class="w"> </span><span class="n">inOrderSuccessor</span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">inOrderHelper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span>
<span class="p">}</span>

<span class="k">func</span><span class="w"> </span><span class="n">inOrderHelper</span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">foundTarget</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">inOrderSuccessor</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">foundTarget</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">foundTarget</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">foundTarget</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">inOrderHelper</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h2>Approach 2</h2>
<p>The second approach was a little trick and even though it may seem like an overkill I am still glad I attempted it this way as I really thought out of my comfort zone  </p>
<p>I picked up the trick from problem <a href="https://leetcode.com/problems/validate-binary-search-tree/description/">validating a binary search tree</a>. You maintain a low &amp; high variables and don't recurse the subtrees where you know solution can't exist. Although now I realize that maintaining the high and low variables was not required, but it still prunes the left subtree where we know an inorder successor can't exist.  </p>
<p>For eg see the below image where if we are searching for <code>13</code> as target node we can prune the subtree marked in red entirely. This solution was ~93% faster than other solutions which makes sense because we don't explore left subtree in some cases<br>
<img alt="subtree" src="https://yagami26.github.io/images/bst-1.jpeg">  </p>
<div class="highlight"><pre><span></span><code><span class="k">var</span><span class="w"> </span><span class="n">foundP</span><span class="w"> </span><span class="nb nb-Type">bool</span>
<span class="k">var</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span>

<span class="k">func</span><span class="w"> </span><span class="n">inorderSuccessor</span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foundP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">false</span>
<span class="w">    </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nil</span>
<span class="w">    </span><span class="n">inorderHelper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">math</span><span class="o">.</span><span class="n">MinInt32</span><span class="p">,</span><span class="w"> </span><span class="n">math</span><span class="o">.</span><span class="n">MaxInt32</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">answer</span>
<span class="p">}</span>

<span class="k">func</span><span class="w"> </span><span class="n">inorderHelper</span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="n">TreeNode</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">iterating</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">subtree</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">values</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">lower</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">p</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">iterating</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">subtree</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">return</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">left</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">inorderHelper</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Left</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">root</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">foundP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">true</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">foundP</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="o">.</span><span class="n">Val</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">right</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">inorderHelper</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">Right</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">.</span><span class="n">Val</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h2>Learnings</h2>
<p>I'm not going to write the original solution mentioned in the editorial, the solution they have mentioned is beautiful. Just as a hint to my future self remember that the trees can be traversed iteratively as well (especially binary search trees). Also iterative solutions will have a benefit of not having a global variable (<em>to satisfy my clean code thought process</em>) and  </p>
<p>the main point being you can store solutions while iterating and start optimising when you store something in an iterative solution, i.e you don't have to wait for a recursion to end. I quite enjoyed solving this problem. </p>
  <footer>
    <p>Published: <time datetime="2024-06-17T20:58:00+05:30">
      Mon 17 June 2024
    </time></p>
    <address>
      By           <a href="https://yagami26.github.io/author/khirod.html">khirod</a>
    </address>
    <p>
        Category: <a href="https://yagami26.github.io/category/algorithms.html">Algorithms</a>
    </p>
    <p>
        Tags:
            <a href="https://yagami26.github.io/tag/leetcode.html">leetcode</a>
            <a href="https://yagami26.github.io/tag/binary-search-tree.html">binary-search-tree</a>
    </p>
  </footer>
  </article>
        </main>
        <footer>
                <address>
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>,
                which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address>
        </footer>
</body>
</html>